import 'isomorphic-fetch';
import { z } from 'zod';

function createFileUploadFormData(file, body) {
  const formData = new FormData();
  const fileToAppend = file instanceof Buffer ? new Blob([file]) : file;
  formData.append("file", fileToAppend);
  formData.append("body", JSON.stringify(body));
  return formData;
}

class Audio {
  constructor(client) {
    this.client = client;
  }
  // Implementation
  async speech_to_text(params, options) {
    if (params instanceof Blob || params instanceof Buffer) {
      const formData = createFileUploadFormData(params, options);
      return await this.client.fetchJSS("/v1/ai/transcribe", "POST", formData);
    }
    return await this.client.fetchJSS("/v1/ai/transcribe", "POST", params);
  }
}

class Classification {
  client;
  constructor(client) {
    this.client = client;
  }
  classify = async (params) => {
    return await this.client.fetchJSS("/v1/classification", "POST", params);
  };
}

const respToFileChoice = (resp) => {
  if (!(resp instanceof Response)) {
    return resp;
  }
  return {
    blob: () => resp.blob(),
    buffer: async () => {
      const arr = await resp.arrayBuffer();
      return Buffer.from(arr);
    },
    file: async (filename, options) => {
      const arr = await resp.arrayBuffer();
      return new File([arr], filename, options);
    }
  };
};
const removeUndefinedProperties = (currentOBJ) => {
  const obj = { ...currentOBJ };
  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
  return obj;
};

class General {
  client;
  constructor(client) {
    this.client = client;
    this.summary = this.summary.bind(this);
    this.embedding = this.embedding.bind(this);
    this.embedding_v2 = this.embedding_v2.bind(this);
  }
  translate = {
    text: async (params) => {
      if (Array.isArray(params.text)) {
        const resp = await this.client.fetchJSS("/v1/ai/translate", "POST", params);
        return resp;
      }
      return await this.client.fetchJSS("/v1/ai/translate", "POST", params);
    },
    image: async (params, options) => {
      if (params instanceof Blob || params instanceof Buffer) {
        const formData = createFileUploadFormData(params, options);
        const resp2 = await this.client.fetchJSS("/v1/ai/translate/image", "POST", formData);
        return respToFileChoice(resp2);
      }
      const resp = await this.client.fetchJSS("/v1/ai/translate/image", "POST", params);
      return respToFileChoice(resp);
    }
  };
  sentiment = async (params) => {
    return await this.client.fetchJSS("/v1/ai/sentiment", "POST", params);
  };
  image_generation = async (params) => {
    const resp = await this.client.fetchJSS("/v1/ai/image_generation", "POST", params);
    return respToFileChoice(resp);
  };
  text_to_sql = async (params) => {
    return await this.client.fetchJSS("/v1/ai/sql", "POST", params);
  };
  async summary(params) {
    if (params.type === "points") {
      const resp = await this.client.fetchJSS("/v1/ai/summary", "POST", params);
      return resp;
    }
    return await this.client.fetchJSS("/v1/ai/summary", "POST", params);
  }
  prediction = async (params) => {
    return await this.client.fetchJSS("/v1/ai/prediction", "POST", params);
  };
  async embedding(params, options) {
    if (params instanceof Blob || params instanceof Buffer) {
      const formData = createFileUploadFormData(params, options);
      return await this.client.fetchJSS("/v1/embedding", "POST", formData);
    }
    return await this.client.fetchJSS("/v1/embedding", "POST", params);
  }
  async embedding_v2(params, options) {
    if (params instanceof Blob || params instanceof Buffer) {
      const formData = createFileUploadFormData(params, options);
      return await this.client.fetchJSS("/v2/embedding", "POST", formData);
    }
    return await this.client.fetchJSS("/v2/embedding", "POST", params);
  }
}

class Stream {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller ?? new AbortController();
  }
  controller;
  static fromReadableStream(readableStream, controller) {
    let _controller = controller;
    if (!_controller) {
      _controller = new AbortController();
    }
    const reader = readableStream.getReader();
    const decoder = new TextDecoder();
    function tryParseData(value) {
      if (!value) return value;
      if (value instanceof Uint8Array) {
        const text = decoder.decode(value);
        try {
          return JSON.parse(text);
        } catch {
          return text;
        }
      }
      return value;
    }
    async function* iterator() {
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          yield tryParseData(value);
        }
      } finally {
        reader.releaseLock();
      }
    }
    return new Stream(iterator, _controller);
  }
  [Symbol.asyncIterator]() {
    const iterator = this.iterator();
    const signal = this.controller.signal;
    return {
      async next(...args) {
        if (signal.aborted) {
          return { done: true, value: void 0 };
        }
        try {
          return await iterator.next(...args);
        } catch (error) {
          if (signal.aborted) {
            return { done: true, value: void 0 };
          }
          throw error;
        }
      },
      async return(value) {
        return iterator.return?.(value) ?? { done: true, value: void 0 };
      },
      async throw(error) {
        return iterator.throw?.(error) ?? { done: true, value: void 0 };
      }
    };
  }
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(controller) {
        try {
          const { value, done } = await iter.next();
          if (done) {
            return controller.close();
          }
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          controller.enqueue(bytes);
        } catch (err) {
          controller.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
        self.controller.abort();
      }
    });
  }
  // Utility method to abort the stream
  abort() {
    this.controller.abort();
  }
}

class PromptEngine {
  constructor(client) {
    this.client = client;
  }
  create = async (params) => {
    return await this.client.fetchJSS("/v1/prompt_engine", "POST", params);
  };
  async run_prompt_direct(params) {
    const resp = await this.client.fetchJSS(`/v1/prompt_engine/run`, "POST", params);
    if (!params.stream) {
      return resp;
    }
    return Stream.fromReadableStream(resp.body);
  }
  get = async (id) => {
    return await this.client.fetchJSS(`/v1/prompt_engine/${id}`, "GET", {});
  };
  list = async (params = { limit: 20, page: 0 }) => {
    return await this.client.fetchJSS("/v1/prompt_engine", "GET", {}, params);
  };
  delete = async (id) => {
    return await this.client.fetchJSS(`/v1/prompt_engine/${id}`, "DELETE", {});
  };
  async run(params) {
    const resp = await this.client.fetchJSS(`/v1/prompt_engine/${params.id}`, "POST", params);
    if (!params.stream) {
      return resp;
    }
    return Stream.fromReadableStream(resp.body);
  }
}

const baseURL = "https://api.jigsawstack.com";
class RequestClient {
  constructor(config) {
    this.config = config;
  }
  fetchJSS = async (path, method, body, searchParams, headers) => {
    const isFileUpload = body instanceof Blob || body instanceof Buffer;
    const isFormData = body instanceof FormData;
    searchParams = searchParams ? removeUndefinedProperties(searchParams) : void 0;
    const _headers = {
      "x-api-key": this.config?.apiKey,
      ...!isFormData && { "Content-Type": isFileUpload ? "application/octet-stream" : "application/json" },
      ...this.config?.headers,
      ...headers
    };
    let _body;
    switch (true) {
      case isFileUpload:
      case isFormData:
        _body = body;
        break;
      default:
        _body = JSON.stringify(body);
    }
    const url = `${this.config?.baseURL || baseURL}${path}`;
    const urlParams = searchParams && Object.keys(searchParams).length ? `?${new URLSearchParams(searchParams).toString()}` : "";
    const resp = await fetch(`${url}${urlParams}`, {
      method,
      headers: _headers,
      body: ["POST", "PATCH"].includes(method) ? _body : void 0
    });
    if (!resp.ok) {
      const error = await resp.json();
      throw error;
    }
    const result = resp.headers.get("Content-Type")?.includes("application/json") ? await resp.json() : resp;
    return result;
  };
}

let File$1 = class File {
  constructor(client) {
    this.client = client;
  }
  upload = async (file, params) => {
    const formData = createFileUploadFormData(file, params);
    return await this.client.fetchJSS(`/v1/store/file`, "POST", formData);
  };
  retrieve = async (key) => {
    const resp = await this.client.fetchJSS(`/v1/store/file/read/${key}`, "GET");
    return respToFileChoice(resp);
  };
  delete = async (key) => {
    return await this.client.fetchJSS(`/v1/store/file/read/${key}`, "DELETE");
  };
};

class Validate {
  constructor(client) {
    this.client = client;
  }
  async nsfw(params, options) {
    if (params instanceof Blob || params instanceof Buffer) {
      const formData = createFileUploadFormData(params, options);
      return await this.client.fetchJSS("/v1/validate/nsfw", "POST", formData);
    }
    return await this.client.fetchJSS("/v1/validate/nsfw", "POST", params);
  }
  profanity = async ({ text, censor_replacement = "*" }) => {
    return await this.client.fetchJSS("/v1/validate/profanity", "POST", { text, censor_replacement });
  };
  spellcheck = async ({ text, language_code = "en" }) => {
    return await this.client.fetchJSS("/v1/validate/spell_check", "POST", { text, language_code });
  };
  async spamcheck({ text }) {
    return await this.client.fetchJSS("/v1/validate/spam_check", "POST", { text });
  }
}

class Vision {
  constructor(client) {
    this.client = client;
  }
  async vocr(params, options) {
    if (params instanceof Blob || params instanceof Buffer) {
      const formData = createFileUploadFormData(params, options);
      return await this.client.fetchJSS("/v1/vocr", "POST", formData);
    }
    return await this.client.fetchJSS("/v1/vocr", "POST", params);
  }
  async object_detection(params, options) {
    if (params instanceof Blob || params instanceof Buffer) {
      const formData = createFileUploadFormData(params, options);
      return await this.client.fetchJSS("/v1/object_detection", "POST", formData);
    }
    return await this.client.fetchJSS("/v1/object_detection", "POST", params);
  }
}

class Web {
  constructor(client) {
    this.client = client;
  }
  ai_scrape = async (params) => {
    return await this.client.fetchJSS("/v1/ai/scrape", "POST", params);
  };
  async html_to_any(params) {
    if (params.return_type === "binary") {
      return await this.client.fetchJSS("/v1/web/html_to_any", "POST", params);
    }
    return await this.client.fetchJSS("/v1/web/html_to_any", "POST", params);
  }
  deep_research = async (params) => {
    return await this.client.fetchJSS("/v1/web/deep_research", "POST", params);
  };
  search = async (params) => {
    return await this.client.fetchJSS("/v1/web/search", "POST", params);
  };
  search_suggestions = async ({ query }) => {
    return await this.client.fetchJSS(`/v1/web/search/suggest?query=${query}`, "GET", void 0);
  };
}

const createBoundMethod = (obj, method) => {
  return (...args) => method.apply(obj, args);
};
const JigsawStack = (config) => {
  const _apiKey = config?.apiKey || process?.env?.JIGSAWSTACK_API_KEY;
  if (!_apiKey) {
    throw new Error("No JigsawStack API key provided");
  }
  const client = new RequestClient({ ...config, apiKey: _apiKey });
  const general = new General(client);
  const web = new Web(client);
  const vision = new Vision(client);
  const audio = new Audio(client);
  const file = new File$1(client);
  const validate = new Validate(client);
  const promptengine = new PromptEngine(client);
  const store = {
    upload: file.upload,
    retrieve: file.retrieve,
    delete: file.delete
  };
  const classification = new Classification(client);
  return {
    sentiment: general.sentiment,
    translate: general.translate,
    image_generation: general.image_generation,
    summary: general.summary,
    prediction: general.prediction,
    text_to_sql: general.text_to_sql,
    embedding: general.embedding,
    embedding_v2: general.embedding_v2,
    audio,
    vision: {
      vocr: createBoundMethod(vision, vision.vocr),
      object_detection: createBoundMethod(vision, vision.object_detection)
    },
    web: {
      ai_scrape: web.ai_scrape,
      html_to_any: createBoundMethod(web, web.html_to_any),
      search: web.search,
      search_suggestions: web.search_suggestions,
      deep_research: web.deep_research
    },
    store,
    validate,
    prompt_engine: promptengine,
    classification: classification.classify
  };
};

function tool(toolDefinition) {
  return {
    type: "function",
    ...toolDefinition
  };
}

class JigsawStackToolSet {
  jigsawStack;
  constructor(config) {
    this.jigsawStack = JigsawStack(config);
  }
  async getTools(options = {}) {
    const { tools: requestedTools = [] } = options;
    const availableTools = this.getAllTools();
    if (requestedTools.length === 0) {
      return availableTools;
    }
    const result = {};
    for (const toolName of requestedTools) {
      if (availableTools[toolName]) {
        result[toolName] = availableTools[toolName];
      }
    }
    return result;
  }
  getAllTools() {
    return {
      // ========== GENERAL TOOLS ==========
      sentiment: tool({
        description: "Analyze sentiment and emotion from text",
        parameters: z.object({
          text: z.string().describe("The text to analyze sentiment for")
        }),
        execute: async ({ text }) => {
          return await this.jigsawStack.sentiment({ text });
        }
      }),
      summary: tool({
        description: "Summarize text content",
        parameters: z.object({
          text: z.string().optional().describe("Text to summarize (max 300,000 characters)"),
          url: z.string().optional().describe("PDF URL to summarize"),
          file_store_key: z.string().optional().describe("File store key for uploaded file"),
          max_characters: z.number().optional().describe("Maximum characters in summary")
        }),
        execute: async ({ text, url, file_store_key, max_characters }) => {
          return await this.jigsawStack.summary({
            text,
            url,
            file_store_key,
            type: "text",
            max_characters
          });
        }
      }),
      translate_text: tool({
        description: "Translate text from one language to another",
        parameters: z.object({
          text: z.string().describe("The text to translate"),
          target_language: z.string().describe('Target language code (e.g., "en", "es", "fr")'),
          current_language: z.string().optional().describe("Current language code (auto-detected if not provided)")
        }),
        execute: async ({ text, target_language, current_language }) => {
          return await this.jigsawStack.translate.text({
            text,
            target_language,
            current_language
          });
        }
      }),
      translate_image: tool({
        description: "Translate text in images from one language to another",
        parameters: z.object({
          url: z.string().optional().describe("URL of the image to translate"),
          file_store_key: z.string().optional().describe("File store key of uploaded image"),
          target_language: z.string().describe('Target language code (e.g., "en", "es", "fr")')
        }),
        execute: async ({ url, file_store_key, target_language }) => {
          return await this.jigsawStack.translate.image({
            url,
            target_language,
            return_type: "url"
          });
        }
      }),
      embedding: tool({
        description: "Generate embeddings for text, images, audio, or PDF content",
        parameters: z.object({
          text: z.string().optional().describe("Text to generate embeddings for"),
          url: z.string().optional().describe("URL of content to generate embeddings for"),
          file_store_key: z.string().optional().describe("File store key of uploaded content"),
          type: z.enum(["text", "text-other", "image", "audio", "pdf"]).describe("Type of content"),
          token_overflow_mode: z.enum(["truncate", "error"]).optional().describe("How to handle token overflow")
        }),
        execute: async ({ text, url, file_store_key, type, token_overflow_mode }) => {
          return await this.jigsawStack.embedding_v2({
            text,
            url,
            file_store_key,
            type,
            token_overflow_mode
          });
        }
      }),
      prediction: tool({
        description: "Make predictions based on historical data",
        parameters: z.object({
          dataset: z.array(
            z.object({
              value: z.union([z.number(), z.string()]).describe("Data value"),
              date: z.string().describe("Date in string format")
            })
          ).describe("Historical dataset for prediction"),
          steps: z.number().describe("Number of prediction steps")
        }),
        execute: async ({ dataset, steps }) => {
          return await this.jigsawStack.prediction({
            dataset,
            steps
          });
        }
      }),
      text_to_sql: tool({
        description: "Convert natural language to SQL queries",
        parameters: z.object({
          prompt: z.string().describe("Natural language description of the SQL query needed"),
          sql_schema: z.string().optional().describe("Database schema (optional)"),
          file_store_key: z.string().optional().describe("File store key for schema file"),
          database: z.enum(["postgresql", "mysql", "sqlite"]).optional().describe("Database type")
        }),
        execute: async ({ prompt, sql_schema, file_store_key, database }) => {
          return await this.jigsawStack.text_to_sql({
            prompt,
            sql_schema,
            file_store_key,
            database
          });
        }
      }),
      // ========== WEB TOOLS ==========
      ai_scrape: tool({
        description: "Scrape and extract data from websites using AI",
        parameters: z.object({
          url: z.string().describe("URL to scrape"),
          element_prompts: z.array(z.string()).describe("Prompts describing what to extract from the webpage"),
          selectors: z.array(z.string()).optional().describe("CSS selectors to extract"),
          root_element_selector: z.string().optional().describe("Root element selector to limit scraping scope")
        }),
        execute: async ({ url, element_prompts, selectors, root_element_selector }) => {
          return await this.jigsawStack.web.ai_scrape({
            url,
            element_prompts,
            selectors,
            root_element_selector
          });
        }
      }),
      html_to_any: tool({
        description: "Convert HTML content to various formats (PDF, PNG, etc.)",
        parameters: z.object({
          html: z.string().optional().describe("HTML content to convert"),
          url: z.string().optional().describe("URL of webpage to convert"),
          type: z.enum(["pdf", "png", "jpeg", "webp"]).optional().describe("Output format type"),
          width: z.number().optional().describe("Output width"),
          height: z.number().optional().describe("Output height"),
          full_page: z.boolean().optional().describe("Capture full page")
        }),
        execute: async ({ html, url, type, width, height, full_page }) => {
          await this.jigsawStack.web.html_to_any({
            html,
            url,
            type,
            width,
            height,
            full_page
          });
          return {
            success: true,
            message: "Successfully converted HTML content",
            format: type || "default",
            note: "Content has been converted. Use jigsawStack.web.html_to_any() directly to get the binary data."
          };
        }
      }),
      web_search: tool({
        description: "Search the web and get AI-powered results",
        parameters: z.object({
          query: z.string().describe("Search query"),
          safe_search: z.enum(["strict", "moderate", "off"]).default("moderate")
        }),
        execute: async ({ query, safe_search }) => {
          return await this.jigsawStack.web.search({
            query,
            safe_search,
            ai_overview: false,
            auto_scrape: false
          });
        }
      }),
      search_suggestions: tool({
        description: "Get search suggestions for a query",
        parameters: z.object({
          query: z.string().describe("Query to get suggestions for")
        }),
        execute: async ({ query }) => {
          return await this.jigsawStack.web.search_suggestions({ query });
        }
      }),
      // ========== VISION TOOLS ==========
      vocr: tool({
        description: "Extract text from images using Vision OCR",
        parameters: z.object({
          prompt: z.union([z.string(), z.array(z.string())]).describe("Prompt(s) for text extraction"),
          url: z.string().optional().describe("URL of image to process"),
          file_store_key: z.string().optional().describe("File store key of uploaded image"),
          page_range: z.array(z.number()).optional().describe("Page range for PDF files")
        }),
        execute: async ({ prompt, url, file_store_key, page_range }) => {
          return await this.jigsawStack.vision.vocr({
            prompt,
            url,
            page_range,
            file_store_key
          });
        }
      }),
      object_detection: tool({
        description: "Detect objects in images",
        parameters: z.object({
          url: z.string().optional().describe("URL of image to analyze"),
          file_store_key: z.string().optional().describe("File store key of uploaded image")
        }),
        execute: async ({ url, file_store_key }) => {
          return await this.jigsawStack.vision.object_detection({
            file_store_key,
            return_type: "url"
          });
        }
      }),
      // ========== AUDIO TOOLS ==========
      speech_to_text: tool({
        description: "Convert speech/audio to text",
        parameters: z.object({
          url: z.string().optional().describe("URL of audio file"),
          file_store_key: z.string().optional().describe("File store key of uploaded audio"),
          language: z.string().optional().describe("Language code for transcription"),
          translate: z.boolean().optional().describe("Translate to English"),
          by_speaker: z.boolean().optional().describe("Separate by speaker")
        }),
        execute: async ({ url, file_store_key, language, translate, by_speaker }) => {
          return await this.jigsawStack.audio.speech_to_text({
            url,
            file_store_key,
            language,
            translate,
            by_speaker
          });
        }
      }),
      // ========== VALIDATION TOOLS ==========
      nsfw_detection: tool({
        description: "Detect NSFW (Not Safe For Work) content in images",
        parameters: z.object({
          url: z.string().optional().describe("URL of image to check"),
          file_store_key: z.string().optional().describe("File store key of uploaded image")
        }),
        execute: async ({ url, file_store_key }) => {
          return await this.jigsawStack.validate.nsfw({
            url,
            file_store_key
          });
        }
      }),
      profanity_check: tool({
        description: "Check and filter profanity in text",
        parameters: z.object({
          text: z.string().describe("Text to check for profanity"),
          censor_replacement: z.string().optional().default("*").describe("Character to replace profanity with")
        }),
        execute: async ({ text, censor_replacement }) => {
          return await this.jigsawStack.validate.profanity({
            text,
            censor_replacement
          });
        }
      }),
      spell_check: tool({
        description: "Check spelling and get auto-corrected text",
        parameters: z.object({
          text: z.string().describe("Text to spell check"),
          language_code: z.string().optional().default("en").describe("Language code for spell checking")
        }),
        execute: async ({ text, language_code }) => {
          return await this.jigsawStack.validate.spellcheck({
            text,
            language_code
          });
        }
      }),
      spam_check: tool({
        description: "Check if text content is spam",
        parameters: z.object({
          text: z.string().describe("Text to check for spam")
        }),
        execute: async ({ text }) => {
          return await this.jigsawStack.validate.spamcheck({ text });
        }
      })
    };
  }
}

export { JigsawStack, JigsawStackToolSet };

import { z } from 'zod';

interface BaseResponse {
    success: boolean;
    _usage?: {
        input_tokens: number;
        output_tokens: number;
        inference_time_tokens: number;
        total_tokens: number;
    };
}
interface BaseConfig {
    apiKey?: string;
    baseURL?: string;
    headers?: Record<string, string>;
}

interface ClassificationResponse extends BaseResponse {
    predictions: (string | string[])[];
}
interface ClassificationParams {
    dataset: Array<{
        type: "text" | "image";
        value: string;
    }>;
    labels: Array<{
        key?: string;
        type: "text" | "image";
        value: string;
    }>;
    multiple_labels?: boolean;
}

interface FileUploadParams {
    overwrite?: boolean;
    key?: string;
    content_type?: string;
    temp_public_url?: boolean;
}
interface FileUploadResponse extends BaseResponse {
    key: string;
    url: string;
    size: number;
    temp_public_url?: string;
}

type ScreenSizeNames = "QVGA" | "VGA" | "SVGA" | "HD" | "SXGA" | "HD+" | "FHD" | "2K" | "2K QHD" | "5K" | "4K UHD" | "8K UHD" | "iPhone 13 Pro" | "iPhone XR" | "iPhone XS" | "iPhone XS Max" | "iPhone X" | "iPhone 8 Plus" | "iPhone 8" | "iPhone 7 Plus" | "iPhone 7" | "iPhone 6 Plus/6S Plus" | "iPhone 6/6S" | "iPhone 5" | "iPod Touch" | "iPad Pro" | "iPad Third & Fourth Generation" | "iPad Air 1 & 2" | "iPad Mini 2 & 3" | "iPad Mini" | "Nexus 6P" | "Nexus 5X" | "Google Pixel 7 Pro" | "Google Pixel 4 XL" | "Google Pixel 4" | "Google Pixel 3a XL" | "Google Pixel 3a" | "Google Pixel 3 XL" | "Google Pixel 3" | "Google Pixel 2 XL" | "Google Pixel XL" | "Google Pixel" | "Samsung Galaxy Note 10+" | "Samsung Galaxy Note 10" | "Samsung Galaxy Note 9" | "Samsung Galaxy Note 5" | "LG G5" | "One Plus 3" | "Samsung Galaxy S9+" | "Samsung Galaxy S9" | "Samsung Galaxy S8+" | "Samsung Galaxy S8" | "Samsung Galaxy S7 Edge" | "Samsung Galaxy S7" | "Nexus 9" | "Nexus 7 (2013)" | "Pixel C" | "Samsung Galaxy Tab 10" | "Chromebook Pixel" | "Letter" | "Legal" | "Tabloid" | "Ledger" | "A0" | "A1" | "A2" | "A3" | "A4" | "A5" | "A6" | "Letter landscape" | "Legal landscape" | "Tabloid landscape" | "Ledger landscape" | "A0 landscape" | "A1 landscape" | "A2 landscape" | "A3 landscape" | "A4 landscape" | "A5 landscape" | "A6 landscape";
type LanguageCodes = "af" | "am" | "ar" | "as" | "az" | "ba" | "be" | "bg" | "bn" | "bo" | "br" | "bs" | "ca" | "ch" | "co" | "cs" | "cy" | "da" | "de" | "dv" | "dz" | "el" | "en" | "eo" | "es" | "et" | "eu" | "fa" | "ff" | "fi" | "fj" | "fo" | "fr" | "fy" | "ga" | "gd" | "gl" | "gu" | "gv" | "ha" | "he" | "hi" | "hr" | "ht" | "hu" | "hy" | "id" | "ig" | "is" | "it" | "iu" | "ja" | "jv" | "ka" | "kg" | "ki" | "kj" | "kk" | "kl" | "km" | "kn" | "ko" | "kr" | "ks" | "ku" | "kv" | "kw" | "ky" | "la" | "lb" | "lg" | "li" | "ln" | "lo" | "lt" | "lu" | "lv" | "mg" | "mh" | "mi" | "mk" | "ml" | "mn" | "mo" | "mr" | "ms" | "mt" | "my" | "na" | "nb" | "nd" | "ne" | "ng" | "nl" | "nn" | "no" | "nr" | "nv" | "ny" | "oc" | "oj" | "om" | "or" | "os" | "pa" | "pi" | "pl" | "ps" | "pt" | "qu" | "rm" | "rn" | "ro" | "ru" | "rw" | "sa" | "sc" | "sd" | "se" | "sg" | "sh" | "si" | "sk" | "sl" | "sm" | "sn" | "so" | "sq" | "sr" | "ss" | "st" | "su" | "sv" | "sw" | "ta" | "te" | "tg" | "th" | "ti" | "tk" | "tl" | "tn" | "to" | "tr" | "ts" | "tt" | "tw" | "ty" | "ug" | "uk" | "ur" | "uz" | "ve" | "vi" | "vo" | "wo" | "xh" | "yi" | "yo" | "zh" | "zh-TW" | "zu";
type CountryCode = "BEN" | "ARG" | "AGO" | "ARM" | "IRN" | "NRU" | "ITA" | "MLI" | "AUS" | "UGA" | "AUT" | "TUR" | "AND" | "AFG" | "ALB" | "DZA" | "ASM" | "AZE" | "BHR" | "BGD" | "BRB" | "BLR" | "BEL" | "BTN" | "BOL" | "BWA" | "BRA" | "BRN" | "BGR" | "BFA" | "KHM" | "CMR" | "CAN" | "CPV" | "CAF" | "TCD" | "CHL" | "CHN" | "COL" | "COK" | "CRI" | "HRV" | "CUB" | "CYP" | "CZE" | "DNK" | "DMA" | "DOM" | "ECU" | "EGY" | "EST" | "ETH" | "SLV" | "FIN" | "FRA" | "GAB" | "GEO" | "IRL" | "DEU" | "GHA" | "GRC" | "GRL" | "GTM" | "GIN" | "GNB" | "GUY" | "HTI" | "HND" | "HUN" | "IND" | "IDN" | "IRQ" | "ISL" | "HKG" | "ISR" | "JAM" | "JPN" | "JOR" | "KAZ" | "KEN" | "KIR" | "KWT" | "KGZ" | "LAO" | "LVA" | "LBN" | "LSO" | "LBR" | "LBY" | "LIE" | "LTU" | "LUX" | "MAC" | "MDG" | "MWI" | "MYS" | "MDV" | "MLT" | "MUS" | "MEX" | "FSM" | "MDA" | "MCO" | "MNG" | "MNE" | "MAR" | "MOZ" | "MMR" | "NAM" | "NPL" | "NLD" | "NZL" | "NIC" | "NER" | "NGA" | "NIU" | "MKD" | "NOR" | "OMN" | "PAK" | "PAN" | "PRY" | "PER" | "PHL" | "POL" | "PRT" | "PRI" | "QAT" | "ROU" | "RUS" | "RWA" | "KNA" | "WSM" | "SMR" | "SAU" | "SEN" | "SRB" | "SYC" | "SLE" | "SVK" | "SVN" | "SLB" | "SOM" | "ZAF" | "SGP" | "KOR" | "SSD" | "ESP" | "LKA" | "SDN" | "SUR" | "SWE" | "CHE" | "SYR" | "TWN" | "TJK" | "TZA" | "THA" | "BHS" | "TGO" | "TON" | "TKM" | "UKR" | "ARE" | "GBR" | "USA" | "URY" | "UZB" | "VUT" | "VEN" | "VNM" | "TUN" | "ZMB" | "ZWE" | "BIH" | "COG" | "CIV" | "COD" | "DJI" | "GNQ" | "ERI" | "MRT" | "PNG" | "TTO" | "YEM" | "BLZ" | "BDI" | "COM" | "SWZ" | "GMB";

interface DeepResearchParams {
    query: string;
    spell_check?: boolean;
    safe_search?: "strict" | "moderate" | "off";
    country_code?: CountryCode | null;
    max_depth?: number;
    max_breadth?: number;
    max_output_tokens?: number;
    target_output_tokens?: number;
}
interface DeepResearchResponse extends BaseResponse {
    query: string;
    results: string;
    sources: SearchResult[];
    geo_results: GeoResult[];
    image_urls: string[];
    links: string[];
}
interface SearchResult {
    title?: string;
    url?: string;
    description?: string;
    content: string | null;
    site_name?: string;
    site_long_name?: string;
    age?: string;
    language?: string;
    image_urls: string[];
    links: string[];
    is_safe?: boolean;
    favicon: string;
    thumbnail?: string;
    snippets?: any[];
    related_index?: RelatedResult[];
}
interface RelatedResult {
    title?: string;
    url?: string;
    description?: string;
    is_safe?: boolean;
}
interface GeoResult {
    type: string;
    full_address: string;
    name: string;
    name_preferred?: string;
    place_formatted?: string;
    postcode?: string;
    district?: string;
    place?: string;
    region?: {
        name: string;
        region_code?: string;
        region_code_full?: string;
    };
    country?: {
        name: string;
        country_code?: string;
        country_code_alpha_3?: string;
    };
    language: string;
    geoloc: {
        type: string;
        coordinates: [number, number];
    };
    poi_category?: string[];
    additional_properties?: any;
}

interface SearchParams {
    query: string;
    spell_check?: boolean;
    max_results?: number;
    safe_search?: "strict" | "moderate" | "off";
    ai_overview?: boolean;
    byo_urls?: string[];
    country_code?: CountryCode;
    auto_scrape?: boolean;
}
interface RelatedIndex {
    title: string;
    url: string;
    description: string;
    is_safe?: boolean;
}
interface SearchResponse extends BaseResponse {
    query: string;
    ai_overview?: string;
    spell_fixed: boolean;
    is_safe: boolean;
    results: Array<{
        title: string;
        url: string;
        description: string;
        content: string | {
            text: string;
            image_urls: string[];
            links: string[];
        };
        is_safe: boolean;
        site_name: string;
        site_long_name: string;
        age: string;
        language: string;
        favicon: string;
        snippets: string[];
        related_index: RelatedIndex[];
    }>;
    image_urls: string[];
    links: string[];
    geo_results: Array<{
        type: string;
        full_address: string;
        name: string;
        name_preferred: string;
        place_formatted: string;
        postcode?: string;
        district?: string;
        place?: string;
        region?: Omit<any, "mapbox_id">;
        country?: Omit<any, "mapbox_id">;
        language: string;
        geoloc: {
            type: string;
            coordinates: number[];
        };
        poi_category?: string;
        additional_properties?: any;
    }>;
}
interface SuggestionResponse extends BaseResponse {
    suggestions: string[];
}

interface HTMLAnyParams {
    html?: string | null;
    url?: string | null;
    goto_options?: {
        timeout: number;
        wait_until: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
    } | null;
    full_page?: boolean;
    omit_background?: boolean;
    type?: "pdf" | "png" | "jpeg" | "webp";
    height?: number;
    width?: number;
    scale?: number;
    is_mobile?: boolean;
    dark_mode?: boolean;
    use_graphic_renderer?: boolean;
    size_preset?: ScreenSizeNames | null;
    pdf_display_header_footer?: boolean;
    pdf_print_background?: boolean;
    pdf_page_range?: string | null;
    return_type?: "url" | "binary" | "base64";
    quality?: number;
}
interface HTMLAnyURLResponse extends BaseResponse {
    url: string;
}
interface HTMLAnyBinaryResponse extends Response {
}
interface HTMLAnyURLParams extends Omit<HTMLAnyParams, "return_type"> {
    return_type: "url" | "base64";
}
interface HTMLAnyBinaryParams extends Omit<HTMLAnyParams, "return_type"> {
    return_type: "binary";
}

interface CookieParameter {
    name: string;
    value: string;
    domain?: string;
    url?: string;
    secure?: boolean;
    httpOnly?: boolean;
    sameParty?: boolean;
    expires?: number;
    priority?: "Low" | "High" | "Medium";
}
interface BaseAIScrapeParams {
    url?: string | null;
    html?: string | null;
    http_headers?: Record<string, string> | null;
    reject_request_pattern?: string[] | null;
    goto_options?: {
        timeout?: number;
        wait_until?: "load" | "domcontentloaded" | "networkidle0" | "networkidle2";
    } | null;
    wait_for?: {
        mode: "selector" | "timeout" | "function";
        value: string | number;
    } | null;
    advance_config?: {
        console?: boolean;
        network?: boolean;
        cookies?: boolean;
    } | null;
    size_preset?: ScreenSizeNames | null;
    is_mobile?: boolean;
    scale?: number;
    width?: number;
    height?: number;
    cookies?: Array<CookieParameter> | null;
    force_rotate_proxy?: boolean;
    byo_proxy?: {
        server: string;
        auth?: {
            username: string;
            password: string;
        };
    } | null;
    features?: Array<"meta" | "link"> | null;
    selectors?: Array<string> | null;
}
interface AIScrapeParams extends BaseAIScrapeParams {
    element_prompts?: string[] | null;
    root_element_selector?: string;
    page_position?: number;
}
interface AIScrapeResponse extends BaseResponse {
    data: Array<{
        key: string;
        selector: string;
        results: Array<{
            html: string;
            text: string;
            attributes: Array<{
                name: string;
                value: string;
            }>;
        }>;
    }>;
    page_position: number;
    page_position_length: number;
    advance_config: {
        console?: any;
        network?: {
            url: string;
            method: string;
            status: number;
            headers: Record<string, string>;
            body: string | null;
            type: "request" | "response";
        };
        cookies?: any;
    } | undefined;
    context: any;
    selectors: Record<string, Array<string>>;
    meta: {
        title: string | undefined;
        description: string | undefined;
        keywords: string | undefined;
        og_image: string | undefined;
    } | undefined;
    link: Array<{
        href: string;
        text: string | null;
        type: "a" | "img";
    }>;
}

type VOCRParams = {
    prompt?: string | string[] | Record<string, string>;
    url?: string;
    file_store_key?: string;
    page_range?: Array<number>;
};
interface VOCRResponse extends BaseResponse {
    context?: string | Record<string, string[]>;
    width: number;
    height: number;
    tags: string[];
    has_text: boolean;
    sections: Array<{
        text: string;
        lines: Array<{
            text: string;
            bounds: BoundingBox;
            average_confidence: number;
            words: Array<{
                text: string;
                bounds: BoundingBox;
                confidence: number;
            }>;
        }>;
    }>;
    total_pages?: number;
    page_range?: Array<number>;
}
type ObjectDetectionParams = {
    url?: string;
    file_store_key?: string;
    prompts?: string[];
    features?: ("object" | "gui")[];
    annotated_image?: boolean;
    return_type?: "url" | "base64";
    return_masks?: boolean;
};
interface ObjectDetectionResponse extends BaseResponse {
    annotated_image?: string;
    gui_elements?: GuiElement[];
    objects?: DetectedObject[];
    tags?: string[];
}
interface GuiElement {
    bounds: BoundingBox;
    content: string | null;
    interactivity: boolean;
    type: string;
}
interface DetectedObject {
    bounds: BoundingBox;
    label: string;
    mask: string | null;
}
interface BoundingBox {
    top_left: Point;
    top_right: Point;
    bottom_left: Point;
    bottom_right: Point;
    width: number;
    height: number;
}
interface Point {
    x: number;
    y: number;
}

declare const respToFileChoice: (resp: Response) => {
    blob: () => Promise<Blob>;
    buffer: () => Promise<Buffer>;
    file: (filename: string, options?: FilePropertyBag) => Promise<File>;
};

type TextToSQLParams = {
    prompt: string;
    database?: "postgresql" | "mysql" | "sqlite";
    sql_schema?: string;
    file_store_key?: string;
};
interface TextToSQLResponse extends BaseResponse {
    sql: string;
}
interface ImageGenerationParams {
    prompt: string;
    aspect_ratio?: "1:1" | "16:9" | "21:9" | "3:2" | "2:3" | "4:5" | "5:4" | "3:4" | "4:3" | "9:16" | "9:21";
    width?: number;
    height?: number;
    steps?: number;
    output_format?: "png" | "svg";
    return_type?: "url" | "binary" | "base64";
    advance_config?: {
        negative_prompt?: string;
        guidance?: number;
        seed?: number;
    };
    url?: string;
    file_store_key?: string;
}
interface SentimentResponse extends BaseResponse {
    sentiment: {
        emotion: string;
        sentiment: string;
        score: number;
        sentences: Array<{
            text: string;
            emotion: string;
            sentiment: string;
            score: number;
        }>;
    };
}
interface TranslateResponse extends BaseResponse {
    translated_text: string | string[];
}
interface TranslateParams {
    text: string | string[];
    current_language?: LanguageCodes;
    target_language: LanguageCodes;
}
type TranslateImageParams = {
    url?: string;
    target_language: string;
    return_type?: "url" | "binary" | "base64";
};
interface SummaryParams {
    text?: string | null;
    url?: string | null;
    type?: "text" | "points";
    file_store_key?: string | null;
    max_points?: number | null;
    max_characters?: number | null;
}
interface PredictionParams {
    dataset: Array<{
        value: number | string;
        date: string;
    }>;
    steps: number;
}
interface PredictionResponse extends BaseResponse {
    prediction: PredictionParams["dataset"];
}
interface EmbeddingParams {
    text?: string;
    url?: string;
    file_store_key?: string;
    file_content?: any;
    type: "text" | "text-other" | "image" | "audio" | "pdf";
    token_overflow_mode?: "truncate" | "error";
}
interface EmbeddingV2Params {
    text?: string;
    url?: string;
    file_store_key?: string;
    file_content?: any;
    type: "text" | "text-other" | "image" | "audio" | "pdf";
    token_overflow_mode?: "truncate" | "error";
    speaker_fingerprint?: boolean;
}
interface EmbeddingV2Response extends BaseResponse {
    embeddings: number[][];
    chunks?: string[] | Array<{
        text: string;
        timestamp: number[];
    }>;
    speaker_embeddings?: number[][];
}
interface EmbeddingResponse extends BaseResponse {
    embeddings: number[][];
    chunks?: Array<{
        text: string;
        timestamp: number[];
    }>;
}

declare class RequestClient {
    private readonly config;
    constructor(config: BaseConfig);
    readonly fetchJSS: (path: string, method: "POST" | "GET" | "DELETE", body?: Record<string, any> | Blob | FormData, searchParams?: {
        [key: string]: any;
    }, headers?: {
        [key: string]: string;
    }) => Promise<any>;
}

interface SpeechToTextParams {
    url?: string;
    file_store_key?: string;
    language?: LanguageCodes | "auto";
    translate?: boolean;
    by_speaker?: boolean;
    webhook_url?: string;
    batch_size?: number;
    chunk_duration?: number;
}
interface SpeechToTextParamsWithWebhook extends SpeechToTextParams {
    webhook_url: string;
}
interface SpeechToTextParamsWithoutWebhook extends Omit<SpeechToTextParams, "webhook_url"> {
    webhook_url?: never;
}
interface SpeechToTextResponse extends BaseResponse {
    text: string;
    chunks: Array<{
        timestamp: number[];
        text: string;
    }>;
    speakers?: Array<{
        speaker: string;
        timestamp: number[];
        text: string;
    }>;
    language_detected?: string;
    confidence?: number;
}
interface SpeechToTextWebhookResponse extends BaseResponse {
    status: "processing" | "error";
    id: string;
}

declare class Audio {
    private readonly client;
    constructor(client: RequestClient);
    speech_to_text(params: SpeechToTextParamsWithWebhook): Promise<SpeechToTextWebhookResponse>;
    speech_to_text(file: Blob | Buffer, params: Omit<SpeechToTextParamsWithWebhook, "url" | "file_store_key">): Promise<SpeechToTextWebhookResponse>;
    speech_to_text(params: SpeechToTextParamsWithoutWebhook): Promise<SpeechToTextResponse>;
    speech_to_text(file: Blob | Buffer, params?: Omit<SpeechToTextParamsWithoutWebhook, "url" | "file_store_key">): Promise<SpeechToTextResponse>;
}

declare class Stream<Item> implements AsyncIterable<Item> {
    private iterator;
    private controller;
    constructor(iterator: () => AsyncIterator<Item>, controller?: AbortController);
    static fromReadableStream<Item>(readableStream: ReadableStream, controller?: AbortController): Stream<Item>;
    [Symbol.asyncIterator](): AsyncIterator<Item>;
    toReadableStream(): ReadableStream<Uint8Array>;
    abort(): void;
}

interface PromptCreateParams {
    prompt: string;
    return_prompt?: string | Array<Record<string, any>> | Record<string, any>;
    inputs?: Array<{
        key: string;
        optional?: boolean;
        initial_value?: string;
    }>;
    use_internet?: boolean;
    optimize_prompt?: boolean;
    prompt_guard?: Array<"defamation" | "specialized_advice" | "privacy" | "intellectual_property" | "indiscriminate_weapons" | "hate" | "sexual_content" | "elections" | "code_interpreter_abuse">;
}
interface PromptRunParams extends Omit<PromptCreateParams, "optimize_prompt"> {
    input_values?: Record<string, any>;
    stream?: boolean;
}
interface PromptExecuteParams {
    id: string;
    input_values?: Record<string, any>;
    stream?: boolean;
}
interface PromptListParams {
    page?: number;
    limit?: number;
}
interface PromptResult {
    id: string;
    prompt: string;
    inputs: Array<{
        key: string;
        optional: boolean;
    }>;
    return_prompt: string;
    created_at: string;
}
interface PromptGetResponse extends PromptResult {
    success: boolean;
}
interface PromptListResponse extends PromptResult {
    prompt_engines: PromptResult[];
}
interface RunPromptResponse {
    result: any;
    success: boolean;
    message?: string;
}
interface RunPromptResponseStream<T> extends Stream<T> {
}
interface RunPromptDirectResponse extends RunPromptResponse {
}

declare class PromptEngine {
    private readonly client;
    constructor(client: RequestClient);
    create: (params: PromptCreateParams) => Promise<{
        prompt_engine_id: string;
    }>;
    run_prompt_direct(params: PromptRunParams & {
        stream: true;
    }): Promise<RunPromptResponseStream<string>>;
    run_prompt_direct(params: PromptRunParams & {
        stream?: false;
    }): Promise<RunPromptDirectResponse>;
    get: (id: string) => Promise<PromptGetResponse>;
    list: (params?: PromptListParams) => Promise<PromptListResponse>;
    delete: (id: string) => Promise<{
        prompt_engine_id: string;
    }>;
    run(params: PromptExecuteParams & {
        stream: true;
    }): Promise<RunPromptResponseStream<string>>;
    run(params: PromptExecuteParams & {
        stream?: false;
    }): Promise<RunPromptResponse>;
}

interface ProfanityParams {
    text: string;
    censor_replacement?: string;
}
interface ProfanityValidationResponse extends BaseResponse {
    message: string;
    clean_text: string;
    profanities: Array<{
        profanity: string | null;
        startIndex: number;
        endIndex: number;
    }>;
    profanities_found: boolean;
}
interface SpellCheckParams {
    text: string;
    language_code?: string;
}
interface SpellCheckValidationResponse extends BaseResponse {
    misspellings_found: boolean;
    misspellings: Array<{
        word: string | null;
        startIndex: number;
        endIndex: number;
        expected: string[];
        auto_corrected: boolean;
    }>;
    auto_correct_text: string;
}
interface SpamCheckValidationResponse extends BaseResponse {
    check: {
        is_spam: boolean;
        score: number;
    };
}
interface SpamCheckValidationArrayResponse extends BaseResponse {
    check: Array<{
        is_spam: boolean;
        score: number;
    }>;
}
interface NSFWParams {
    url?: string;
    file_store_key?: string;
}
interface NSFWValidationResponse extends BaseResponse {
    nsfw: boolean;
    nudity: boolean;
    gore: boolean;
    nsfw_score: number;
    nudity_score: number;
    gore_score: number;
}

declare class Validate {
    private readonly client;
    constructor(client: RequestClient);
    nsfw(params: NSFWParams): Promise<NSFWValidationResponse>;
    nsfw(file: Blob | Buffer, params?: Omit<NSFWParams, "url" | "file_store_key">): Promise<NSFWValidationResponse>;
    profanity: ({ text, censor_replacement }: ProfanityParams) => Promise<ProfanityValidationResponse>;
    spellcheck: ({ text, language_code }: SpellCheckParams) => Promise<SpellCheckValidationResponse>;
    spamcheck({ text }: {
        text: string;
    }): Promise<SpamCheckValidationResponse>;
    spamcheck({ text }: {
        text: string[];
    }): Promise<SpamCheckValidationArrayResponse>;
}

declare const JigsawStack: (config?: BaseConfig) => {
    sentiment: (params: {
        text: string;
    }) => Promise<SentimentResponse>;
    translate: {
        text: (params: TranslateParams) => Promise<TranslateResponse | (BaseResponse & {
            translated_text: string[];
        })>;
        image: (params: Blob | Buffer | TranslateImageParams, options?: Omit<TranslateImageParams, "file_store_key" | "url">) => Promise<ReturnType<typeof respToFileChoice>>;
    };
    image_generation: (params: ImageGenerationParams) => Promise<{
        blob: () => Promise<Blob>;
        buffer: () => Promise<Buffer>;
        file: (filename: string, options?: FilePropertyBag) => Promise<globalThis.File>;
    }>;
    summary: {
        (params: SummaryParams & {
            type: "points";
        }): Promise<BaseResponse & {
            summary: string[];
        }>;
        (params: SummaryParams & {
            type: "text";
        }): Promise<BaseResponse & {
            summary: string;
        }>;
    };
    prediction: (params: PredictionParams) => Promise<PredictionResponse>;
    text_to_sql: (params: TextToSQLParams) => Promise<TextToSQLResponse>;
    embedding: {
        (params: EmbeddingParams): Promise<EmbeddingResponse>;
        (file: Blob | Buffer, params: Omit<EmbeddingParams, "url" | "file_store_key" | "file_content">): Promise<EmbeddingResponse>;
    };
    embedding_v2: {
        (params: EmbeddingV2Params): Promise<EmbeddingV2Response>;
        (file: Blob | Buffer, params: Omit<EmbeddingV2Params, "url" | "file_store_key" | "file_content">): Promise<EmbeddingV2Response>;
    };
    audio: Audio;
    vision: {
        vocr: {
            (params: VOCRParams): Promise<VOCRResponse>;
            (file: Blob | Buffer, params?: Omit<VOCRParams, "url" | "file_store_key">): Promise<VOCRResponse>;
        };
        object_detection: {
            (params: ObjectDetectionParams): Promise<ObjectDetectionResponse>;
            (file: Blob | Buffer, params?: Omit<ObjectDetectionParams, "url" | "file_store_key">): Promise<ObjectDetectionResponse>;
        };
    };
    web: {
        ai_scrape: (params: AIScrapeParams) => Promise<AIScrapeResponse>;
        html_to_any: {
            (params: HTMLAnyURLParams): Promise<HTMLAnyURLResponse>;
            (params: HTMLAnyBinaryParams): Promise<HTMLAnyBinaryResponse>;
            (params: HTMLAnyParams): Promise<HTMLAnyURLResponse | HTMLAnyBinaryResponse>;
        };
        search: (params: SearchParams) => Promise<SearchResponse>;
        search_suggestions: ({ query }: {
            query: string;
        }) => Promise<SuggestionResponse>;
        deep_research: (params: DeepResearchParams) => Promise<DeepResearchResponse>;
    };
    store: {
        upload: (file: Blob | Buffer, params?: FileUploadParams) => Promise<FileUploadResponse>;
        retrieve: (key: string) => Promise<{
            blob: () => Promise<Blob>;
            buffer: () => Promise<Buffer>;
            file: (filename: string, options?: FilePropertyBag) => Promise<globalThis.File>;
        }>;
        delete: (key: string) => Promise<BaseResponse>;
    };
    validate: Validate;
    prompt_engine: PromptEngine;
    classification: (params: ClassificationParams) => Promise<ClassificationResponse>;
};

type ToolParameters = z.ZodTypeAny;
interface ToolExecutionOptions {
    toolCallId: string;
    messages: any[];
    abortSignal?: AbortSignal;
}
type inferParameters<PARAMETERS extends ToolParameters> = PARAMETERS extends z.ZodTypeAny ? z.infer<PARAMETERS> : never;
interface Tool<PARAMETERS extends ToolParameters = any, RESULT = any> {
    /**
     * The schema of the input that the tool expects.
     */
    parameters: PARAMETERS;
    /**
     * An optional description of what the tool does.
     */
    description?: string;
    /**
     * An async function that is called with the arguments from the tool call.
     */
    execute?: (args: inferParameters<PARAMETERS>, options: ToolExecutionOptions) => PromiseLike<RESULT>;
    /**
     * Function tool (default type)
     */
    type?: undefined | "function";
}

interface JigsawStackToolOptions {
    tools?: string[];
}
declare class JigsawStackToolSet {
    private jigsawStack;
    constructor(config?: BaseConfig);
    getTools(options?: JigsawStackToolOptions): Promise<Record<string, any> | {
        sentiment: Tool<z.ZodObject<{
            text: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            text?: string;
        }, {
            text?: string;
        }>, SentimentResponse>;
        summary: Tool<z.ZodObject<{
            text: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
            max_characters: z.ZodOptional<z.ZodNumber>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
            text?: string;
            max_characters?: number;
        }, {
            url?: string;
            file_store_key?: string;
            text?: string;
            max_characters?: number;
        }>, BaseResponse & {
            summary: string;
        }>;
        translate_text: Tool<z.ZodObject<{
            text: z.ZodString;
            target_language: z.ZodString;
            current_language: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            text?: string;
            target_language?: string;
            current_language?: string;
        }, {
            text?: string;
            target_language?: string;
            current_language?: string;
        }>, TranslateResponse | (BaseResponse & {
            translated_text: string[];
        })>;
        translate_image: Tool<z.ZodObject<{
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
            target_language: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
            target_language?: string;
        }, {
            url?: string;
            file_store_key?: string;
            target_language?: string;
        }>, {
            blob: () => Promise<Blob>;
            buffer: () => Promise<Buffer>;
            file: (filename: string, options?: FilePropertyBag) => Promise<File>;
        }>;
        embedding: Tool<z.ZodObject<{
            text: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
            type: z.ZodEnum<["text", "text-other", "image", "audio", "pdf"]>;
            token_overflow_mode: z.ZodOptional<z.ZodEnum<["truncate", "error"]>>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
            type?: "text" | "image" | "text-other" | "audio" | "pdf";
            text?: string;
            token_overflow_mode?: "error" | "truncate";
        }, {
            url?: string;
            file_store_key?: string;
            type?: "text" | "image" | "text-other" | "audio" | "pdf";
            text?: string;
            token_overflow_mode?: "error" | "truncate";
        }>, EmbeddingV2Response>;
        prediction: Tool<z.ZodObject<{
            dataset: z.ZodArray<z.ZodObject<{
                value: z.ZodUnion<[z.ZodNumber, z.ZodString]>;
                date: z.ZodString;
            }, "strip", z.ZodTypeAny, {
                value?: string | number;
                date?: string;
            }, {
                value?: string | number;
                date?: string;
            }>, "many">;
            steps: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            dataset?: {
                value?: string | number;
                date?: string;
            }[];
            steps?: number;
        }, {
            dataset?: {
                value?: string | number;
                date?: string;
            }[];
            steps?: number;
        }>, PredictionResponse>;
        text_to_sql: Tool<z.ZodObject<{
            prompt: z.ZodString;
            sql_schema: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
            database: z.ZodOptional<z.ZodEnum<["postgresql", "mysql", "sqlite"]>>;
        }, "strip", z.ZodTypeAny, {
            file_store_key?: string;
            prompt?: string;
            sql_schema?: string;
            database?: "postgresql" | "mysql" | "sqlite";
        }, {
            file_store_key?: string;
            prompt?: string;
            sql_schema?: string;
            database?: "postgresql" | "mysql" | "sqlite";
        }>, TextToSQLResponse>;
        ai_scrape: Tool<z.ZodObject<{
            url: z.ZodString;
            element_prompts: z.ZodArray<z.ZodString, "many">;
            selectors: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
            root_element_selector: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            element_prompts?: string[];
            root_element_selector?: string;
            selectors?: string[];
        }, {
            url?: string;
            element_prompts?: string[];
            root_element_selector?: string;
            selectors?: string[];
        }>, AIScrapeResponse>;
        html_to_any: Tool<z.ZodObject<{
            html: z.ZodOptional<z.ZodString>;
            url: z.ZodOptional<z.ZodString>;
            type: z.ZodOptional<z.ZodEnum<["pdf", "png", "jpeg", "webp"]>>;
            width: z.ZodOptional<z.ZodNumber>;
            height: z.ZodOptional<z.ZodNumber>;
            full_page: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            type?: "png" | "pdf" | "jpeg" | "webp";
            html?: string;
            full_page?: boolean;
            height?: number;
            width?: number;
        }, {
            url?: string;
            type?: "png" | "pdf" | "jpeg" | "webp";
            html?: string;
            full_page?: boolean;
            height?: number;
            width?: number;
        }>, {
            success: boolean;
            message: string;
            format: string;
            note: string;
        }>;
        web_search: Tool<z.ZodObject<{
            query: z.ZodString;
            safe_search: z.ZodDefault<z.ZodEnum<["strict", "moderate", "off"]>>;
        }, "strip", z.ZodTypeAny, {
            query?: string;
            safe_search?: "strict" | "moderate" | "off";
        }, {
            query?: string;
            safe_search?: "strict" | "moderate" | "off";
        }>, SearchResponse>;
        search_suggestions: Tool<z.ZodObject<{
            query: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            query?: string;
        }, {
            query?: string;
        }>, SuggestionResponse>;
        vocr: Tool<z.ZodObject<{
            prompt: z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, "many">]>;
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
            page_range: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
            prompt?: string | string[];
            page_range?: number[];
        }, {
            url?: string;
            file_store_key?: string;
            prompt?: string | string[];
            page_range?: number[];
        }>, VOCRResponse>;
        object_detection: Tool<z.ZodObject<{
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
        }, {
            url?: string;
            file_store_key?: string;
        }>, ObjectDetectionResponse>;
        speech_to_text: Tool<z.ZodObject<{
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
            language: z.ZodOptional<z.ZodString>;
            translate: z.ZodOptional<z.ZodBoolean>;
            by_speaker: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
            language?: string;
            translate?: boolean;
            by_speaker?: boolean;
        }, {
            url?: string;
            file_store_key?: string;
            language?: string;
            translate?: boolean;
            by_speaker?: boolean;
        }>, SpeechToTextResponse>;
        nsfw_detection: Tool<z.ZodObject<{
            url: z.ZodOptional<z.ZodString>;
            file_store_key: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            url?: string;
            file_store_key?: string;
        }, {
            url?: string;
            file_store_key?: string;
        }>, NSFWValidationResponse>;
        profanity_check: Tool<z.ZodObject<{
            text: z.ZodString;
            censor_replacement: z.ZodDefault<z.ZodOptional<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            text?: string;
            censor_replacement?: string;
        }, {
            text?: string;
            censor_replacement?: string;
        }>, ProfanityValidationResponse>;
        spell_check: Tool<z.ZodObject<{
            text: z.ZodString;
            language_code: z.ZodDefault<z.ZodOptional<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            text?: string;
            language_code?: string;
        }, {
            text?: string;
            language_code?: string;
        }>, SpellCheckValidationResponse>;
        spam_check: Tool<z.ZodObject<{
            text: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            text?: string;
        }, {
            text?: string;
        }>, SpamCheckValidationResponse>;
    }>;
    private getAllTools;
}

export { JigsawStack, JigsawStackToolSet };
